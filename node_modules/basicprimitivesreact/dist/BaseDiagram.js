"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _basicprimitives = _interopRequireDefault(require("basicprimitives"));

var _Graphics = _interopRequireDefault(require("./Graphics"));

var _Templates = require("./Templates");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var BaseDiagram =
/*#__PURE__*/
function (_Component) {
  _inherits(BaseDiagram, _Component);

  function BaseDiagram(props, namespace) {
    var _this;

    _classCallCheck(this, BaseDiagram);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseDiagram).call(this, props));
    _this.namespace = namespace;
    var config = props.config,
        centerOnCursor = props.centerOnCursor;
    var highlightItem = config.highlightItem,
        cursorItem = config.cursorItem,
        selectedItems = config.selectedItems;
    _this.state = {
      viewportSize: {
        width: 0,
        height: 0
      },
      contentPosition: {
        x: 0,
        y: 0
      },
      centerOnCursor: centerOnCursor,
      highlightItem: highlightItem,
      cursorItem: cursorItem,
      selectedItems: (selectedItems || []).slice()
    };
    var viewportSize = _this.state.viewportSize;
    _this.onRefreshViewport = _this.onRefreshViewport.bind(_assertThisInitialized(_this));
    _this.onSizeChanged = _this.onSizeChanged.bind(_assertThisInitialized(_this));
    _this.onScroll = _this.onScroll.bind(_assertThisInitialized(_this));
    _this.onMouseMove = _this.onMouseMove.bind(_assertThisInitialized(_this));
    _this.onClick = _this.onClick.bind(_assertThisInitialized(_this));
    _this.onCheckboxChange = _this.onCheckboxChange.bind(_assertThisInitialized(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized(_this));
    _this.getOptions = _this.getOptions.bind(_assertThisInitialized(_this));
    _this.getGraphics = _this.getGraphics.bind(_assertThisInitialized(_this));
    _this.getLayout = _this.getLayout.bind(_assertThisInitialized(_this));
    _this.setLayout = _this.setLayout.bind(_assertThisInitialized(_this));
    _this.getEventArgs = _this.getEventArgs.bind(_assertThisInitialized(_this));
    _this.centerOnCursor = _this.centerOnCursor.bind(_assertThisInitialized(_this));
    _this.onItemRender = _this.onItemRender.bind(_assertThisInitialized(_this));
    _this.onHighlightRender = _this.onHighlightRender.bind(_assertThisInitialized(_this));
    _this.onCursorRender = _this.onCursorRender.bind(_assertThisInitialized(_this));
    _this.scrollPanelRef = _react["default"].createRef();
    _this.mousePanelRef = _react["default"].createRef();
    _this.placeholderRef = _react["default"].createRef();
    _this.calloutPlaceholderRef = _react["default"].createRef();
    _this.layoutOptions = {};
    _this.templatesHash = {};
    _this.graphics = new _Graphics["default"](viewportSize);
    _this.templates = {
      AnnotationLabelTemplate: _Templates.AnnotationLabelTemplate,
      ButtonsTemplate: _Templates.ButtonsTemplate,
      CheckBoxTemplate: _Templates.CheckBoxTemplate,
      CursorTemplate: _Templates.CursorTemplate,
      DotHighlightTemplate: _Templates.DotHighlightTemplate,
      GroupTitleTemplate: _Templates.GroupTitleTemplate,
      HighlightTemplate: _Templates.HighlightTemplate,
      ItemTemplate: _Templates.ItemTemplate,
      UserTemplate: _Templates.UserTemplate,
      LabelAnnotationTemplate: _Templates.LabelAnnotationTemplate
    };
    _this.tasks = namespace.TaskManagerFactory(_this.getOptions, _this.getGraphics, _this.getLayout, _this.setLayout, _this.templates);
    return _this;
  }

  _createClass(BaseDiagram, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var nextConfig = nextProps.config,
          centerOnCursor = nextProps.centerOnCursor;
      var config = this.props.config;

      if (config !== nextConfig) {
        var highlightItem = nextConfig.highlightItem,
            cursorItem = nextConfig.cursorItem,
            selectedItems = nextConfig.selectedItems;
        this.setState({
          highlightItem: highlightItem,
          cursorItem: cursorItem,
          selectedItems: (selectedItems || []).slice(),
          centerOnCursor: centerOnCursor
        });
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      // The following code is ResizeObserver Polyfill
      // It is added to the rendered page to track size changes of control placeholder
      // npm install resize-observer-polyfill --save-dev
      require('resize-observer-polyfill/dist/ResizeObserver.global');

      this.observer = new ResizeObserver(this.onSizeChanged);
      this.observer.observe(this.scrollPanelRef.current);
      this.centerOnCursor();
      this.fixPixelAlignment();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      // destroy timer
      clearTimeout(this.timer);
      this.timer = null; // destroy observer

      this.observer.disconnect();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.centerOnCursor();
    }
  }, {
    key: "centerOnCursor",
    value: function centerOnCursor() {
      var centerOnCursor = this.state.centerOnCursor;

      if (centerOnCursor) {
        /* scroll to offset */
        var centerOnCursorTask = this.tasks.getTask("CenterOnCursorTask");
        var placeholderOffset = centerOnCursorTask.getPlaceholderOffset();
        var scrollLeft = placeholderOffset.x,
            scrollTop = placeholderOffset.y;
        this.scrollPanelRef.current.scrollLeft = scrollLeft;
        this.scrollPanelRef.current.scrollTop = scrollTop;
      }
    }
  }, {
    key: "fixPixelAlignment",
    value: function fixPixelAlignment() {
      var current = this.scrollPanelRef.current;

      var pixelAlignmentFix = _basicprimitives["default"].common.getFixOfPixelALignment(current);

      current.style.marginLeft = pixelAlignmentFix.width + "px";
      current.style.marginTop = pixelAlignmentFix.height + "px";
    }
  }, {
    key: "onSizeChanged",
    value: function onSizeChanged() {
      var _primitives$common$ge = _basicprimitives["default"].common.getInnerSize(this.scrollPanelRef.current),
          width = _primitives$common$ge.width,
          height = _primitives$common$ge.height;

      this.setState({
        viewportSize: {
          width: width,
          height: height
        },
        centerOnCursor: true
      });
    }
  }, {
    key: "onScroll",
    value: function onScroll() {
      if (this.timer == null) {
        this.timer = setTimeout(this.onRefreshViewport, 200);
      }
    }
  }, {
    key: "onRefreshViewport",
    value: function onRefreshViewport() {
      clearTimeout(this.timer);
      this.timer = null;
      var _this$scrollPanelRef$ = this.scrollPanelRef.current,
          scrollTop = _this$scrollPanelRef$.scrollTop,
          scrollLeft = _this$scrollPanelRef$.scrollLeft;
      this.setState({
        contentPosition: {
          x: Math.floor(scrollLeft),
          y: Math.floor(scrollTop)
        },
        centerOnCursor: false
      });
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      var placeholderOffset = _basicprimitives["default"].common.getElementOffset(this.mousePanelRef.current),
          x = event.pageX - placeholderOffset.left,
          y = event.pageY - placeholderOffset.top,
          createTransformTask = this.tasks.getTask("CreateTransformTask"),
          highlightItemOptionTask = this.tasks.getTask("HighlightItemOptionTask");

      if (highlightItemOptionTask.hasHighlightEnabled()) {
        var itemId = createTransformTask.getTreeItemForMousePosition(x, y, highlightItemOptionTask.getGravityRadius());
        this.setHighlightItem(event, itemId);
      }
    }
  }, {
    key: "getEventArgs",
    value: function getEventArgs(oldTreeItemId, newTreeItemId, name) {
      var result = new this.namespace.EventArgs(),
          combinedContextsTask = this.tasks.getTask("CombinedContextsTask"),
          alignDiagramTask = this.tasks.getTask("AlignDiagramTask"),
          oldItemConfig = combinedContextsTask.getConfig(oldTreeItemId),
          newItemConfig = combinedContextsTask.getConfig(newTreeItemId),
          itemPosition,
          offset,
          panelOffset;

      if (oldItemConfig && oldItemConfig.id != null) {
        result.oldContext = oldItemConfig;
      }

      if (newItemConfig && newItemConfig.id != null) {
        result.context = newItemConfig;

        if (newItemConfig.parent !== null) {
          result.parentItem = combinedContextsTask.getConfig(newItemConfig.parent);
        }

        panelOffset = _basicprimitives["default"].common.getElementOffset(this.mousePanelRef.current);
        offset = _basicprimitives["default"].common.getElementOffset(this.scrollPanelRef.current);
        itemPosition = alignDiagramTask.getItemPosition(newTreeItemId);
        result.position = new _basicprimitives["default"].common.Rect(itemPosition.actualPosition).translate(panelOffset.left, panelOffset.top).translate(-offset.left, -offset.top);
      }

      if (name != null) {
        result.name = name;
      }

      return result;
    }
  }, {
    key: "setHighlightItem",
    value: function setHighlightItem(event, newHighlightItemId) {
      var eventArgs,
          cancel = false;
      var _this$props = this.props,
          onHighlightChanging = _this$props.onHighlightChanging,
          onHighlightChanged = _this$props.onHighlightChanged;
      var highlightItem = this.state.highlightItem;

      if (newHighlightItemId !== highlightItem) {
        eventArgs = this.getEventArgs(highlightItem, newHighlightItemId);

        if (onHighlightChanging != null) {
          if (!onHighlightChanging(event, eventArgs)) {
            cancel = true;
            this.setState({
              highlightItem: newHighlightItemId
            });
          }
        } else {
          this.setState({
            highlightItem: newHighlightItemId
          });
        }

        ;

        if (!cancel) {
          if (onHighlightChanged != null) {
            onHighlightChanged(event, eventArgs);
          }
        }
      }
    }
  }, {
    key: "setCursorItem",
    value: function setCursorItem(event, newCursorItemId) {
      var eventArgs,
          cancel = false;
      var _this$props2 = this.props,
          onCursorChanging = _this$props2.onCursorChanging,
          onCursorChanged = _this$props2.onCursorChanged;
      var cursorItem = this.state.cursorItem;

      if (newCursorItemId !== cursorItem) {
        eventArgs = this.getEventArgs(cursorItem, newCursorItemId);

        if (onCursorChanging != null) {
          if (!onCursorChanging(event, eventArgs)) {
            cancel = true;
            this.setState({
              cursorItem: newCursorItemId,
              centerOnCursor: true
            });
          }
        } else {
          this.setState({
            cursorItem: newCursorItemId,
            centerOnCursor: true
          });
        }

        if (!cancel) {
          if (onCursorChanged != null) {
            onCursorChanged(event, eventArgs);
          }
        }
      }
    }
  }, {
    key: "onClick",
    value: function onClick(event) {
      var placeholderOffset = _basicprimitives["default"].common.getElementOffset(this.mousePanelRef.current),
          x = event.pageX - placeholderOffset.left,
          y = event.pageY - placeholderOffset.top,
          createTransformTask = this.tasks.getTask("CreateTransformTask"),
          cursorItemOptionTask = this.tasks.getTask("CursorItemOptionTask"),
          highlightItemOptionTask = this.tasks.getTask("HighlightItemOptionTask"),
          newCursorItemId = createTransformTask.getTreeItemForMousePosition(x, y, highlightItemOptionTask.getGravityRadius()),
          target;

      target = event.target;

      if (newCursorItemId !== null) {
        if (target.getAttribute("name") === "checkbox" || target.getAttribute("name") === "selectiontext") {//ignore jslint
        } else {
          if (cursorItemOptionTask.hasCursorEnabled()) {
            this.setCursorItem(event, newCursorItemId);
            this.scrollPanelRef.current.focus();
          }
        }
      }
    }
  }, {
    key: "onCheckboxChange",
    value: function onCheckboxChange(event) {
      var _this$props3 = this.props,
          onSelectionChanging = _this$props3.onSelectionChanging,
          onSelectionChanged = _this$props3.onSelectionChanged;
      var selectedItems = this.state.selectedItems;
      var newSelectedItems = [];
      var target = event.target;
      var itemid = target.getAttribute("data-id");
      var checked = event.target.checked;
      var cancel = false;

      if (itemid != null) {
        if (checked) {
          newSelectedItems = [].concat(_toConsumableArray(selectedItems), [itemid]);
        } else {
          // eslint-disable-next-line
          newSelectedItems = selectedItems.filter(function (id) {
            return id != itemid;
          }); // User type may not mach string value in data attribute
        }

        if (onSelectionChanging != null) {
          cancel = onSelectionChanging(event, selectedItems, newSelectedItems);
        }

        if (!cancel) {
          this.setState({
            selectedItems: newSelectedItems
          });

          if (onSelectionChanged != null) {
            onSelectionChanged(event, selectedItems, newSelectedItems);
          }
        }
      }
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      var highlightItemTask = this.tasks.getTask("HighlightItemTask"),
          highlightItemOptionTask = this.tasks.getTask("HighlightItemOptionTask"),
          cursorItemTask = this.tasks.getTask("CursorItemTask"),
          cursorItemOptionTask = this.tasks.getTask("CursorItemOptionTask"),
          alignDiagramTask = this.tasks.getTask('AlignDiagramTask'),
          createTransformTask = this.tasks.getTask('CreateTransformTask'),
          transform = createTransformTask.getTransform(),
          navigationItem = null,
          newNavigationItem,
          direction = null,
          accepted;

      if (highlightItemOptionTask.hasHighlightEnabled() && cursorItemOptionTask.hasCursorEnabled()) {
        navigationItem = highlightItemTask.getHighlightTreeItem();

        if (navigationItem === null) {
          navigationItem = cursorItemTask.getCursorTreeItem();
        }
      } else if (highlightItemOptionTask.hasHighlightEnabled()) {
        navigationItem = highlightItemTask.getHighlightTreeItem();
      } else if (cursorItemOptionTask.hasCursorEnabled()) {
        navigationItem = cursorItemTask.getCursorTreeItem();
      }

      if (navigationItem != null) {
        switch (event.which) {
          case 13:
            /*Enter*/
            if (cursorItemOptionTask.hasCursorEnabled()) {
              this.setCursorItem(event, navigationItem);
              event.preventDefault();
              this.scrollPanelRef.current.focus();
            }

            break;

          case 40:
            /*Down*/
            direction = _basicprimitives["default"].common.OrientationType.Bottom;
            break;

          case 38:
            /*Up*/
            direction = _basicprimitives["default"].common.OrientationType.Top;
            break;

          case 37:
            /*Left*/
            direction = _basicprimitives["default"].common.OrientationType.Left;
            break;

          case 39:
            /*Right*/
            direction = _basicprimitives["default"].common.OrientationType.Right;
            break;

          default:
            break;
        }

        if (direction != null) {
          accepted = false;

          while (!accepted) {
            accepted = true;
            direction = transform.getOrientation(direction);
            newNavigationItem = alignDiagramTask.getNextItem(navigationItem, direction);

            if (newNavigationItem != null) {
              event.preventDefault();

              if (highlightItemOptionTask.hasHighlightEnabled()) {
                this.setHighlightItem(event, newNavigationItem);
              } else if (cursorItemOptionTask.hasCursorEnabled()) {
                this.setCursorItem(event, newNavigationItem);
              }
            }
          }

          this.scrollPanelRef.current.focus();
        }
      }
    }
  }, {
    key: "onItemRender",
    value: function onItemRender(data) {
      var templateName = data.templateName;
      var template = this.templatesHash[templateName];
      return template.onItemRender(data);
    }
  }, {
    key: "onHighlightRender",
    value: function onHighlightRender(data) {
      var templateName = data.templateName;
      var template = this.templatesHash[templateName];
      return template.onHighlightRender(data);
    }
  }, {
    key: "onCursorRender",
    value: function onCursorRender(data) {
      var templateName = data.templateName;
      var template = this.templatesHash[templateName];
      return template.onCursorRender(data);
    }
  }, {
    key: "getOptions",
    value: function getOptions() {
      var config = this.props.config;
      var templates = config.templates || [];
      var effectiveTemplates = templates.map(function (template) {
        var onItemRender = template.onItemRender,
            onHighlightRender = template.onHighlightRender,
            onCursorRender = template.onCursorRender;
        return _objectSpread({}, template, {
          itemTemplate: !onItemRender ? null : "<p>This template is not being used in React</p>",
          highlightTemplate: !onHighlightRender ? null : "<p>This template is not being used in React</p>",
          cursorTemplate: !onCursorRender ? null : "<p>This template is not being used in React</p>"
        });
      });
      this.templatesHash = templates.reduce(function (agg, template) {
        var name = template.name;
        agg[name] = template;
        return agg;
      }, {});
      var _this$state = this.state,
          highlightItem = _this$state.highlightItem,
          cursorItem = _this$state.cursorItem,
          selectedItems = _this$state.selectedItems;
      return _objectSpread({}, config, {
        templates: effectiveTemplates,
        highlightItem: highlightItem,
        cursorItem: cursorItem,
        selectedItems: selectedItems,
        onItemRender: this.onItemRender,
        onCursorRender: this.onCursorRender,
        onHighlightRender: this.onHighlightRender
      });
    }
  }, {
    key: "getGraphics",
    value: function getGraphics() {
      return this.graphics;
    }
  }, {
    key: "getLayout",
    value: function getLayout() {
      var _this$state2 = this.state,
          centerOnCursor = _this$state2.centerOnCursor,
          viewportSize = _this$state2.viewportSize,
          contentPosition = _this$state2.contentPosition;
      return {
        forceCenterOnCursor: centerOnCursor,
        scrollPanelSize: viewportSize,
        placeholderOffset: contentPosition
      };
    }
  }, {
    key: "setLayout",
    value: function setLayout(layoutOptions) {
      var autoSize = layoutOptions.autoSize,
          scale = layoutOptions.scale,
          contentSize = layoutOptions.contentSize,
          scrollPanelSize = layoutOptions.scrollPanelSize,
          autoSizeMinimum = layoutOptions.autoSizeMinimum,
          autoSizeMaximum = layoutOptions.autoSizeMaximum;
      /* set size of panel with content */

      var mousePanelSize = new _basicprimitives["default"].common.Size(contentSize);
      mousePanelSize.scale(1 * scale);
      var scrollPanelAutoSize = new _basicprimitives["default"].common.Size(scrollPanelSize);

      if (autoSize) {
        /* resize element to fit placeholder if control in autosize mode */
        scrollPanelAutoSize = new _basicprimitives["default"].common.Size(mousePanelSize.width + 25, mousePanelSize.height + 25);
        scrollPanelAutoSize.cropBySize(autoSizeMaximum);
        scrollPanelAutoSize.addSize(autoSizeMinimum); //ignore jslint
      }

      this.layoutOptions = {
        autoSize: autoSize,
        scrollPanelSize: scrollPanelAutoSize,
        mousePanelSize: mousePanelSize,
        scale: scale
      };
      return scrollPanelAutoSize;
    }
  }, {
    key: "render",
    value: function render() {
      var graphics = this.graphics;
      this.tasks.process('OptionsTask', null, false);
      var _this$graphics$placeh = this.graphics.placeholders,
          placeholder = _this$graphics$placeh.placeholder,
          calloutplaceholder = _this$graphics$placeh.calloutplaceholder;
      var placeholderRectCSS = placeholder.rect.getCSS();
      var _this$layoutOptions = this.layoutOptions,
          autoSize = _this$layoutOptions.autoSize,
          scale = _this$layoutOptions.scale,
          scrollPanelSize = _this$layoutOptions.scrollPanelSize,
          mousePanelSize = _this$layoutOptions.mousePanelSize;
      /* set CSS scale of content */

      var scaletext = "scale(" + scale + "," + scale + ")";
      return _react["default"].createElement(_react["default"].Fragment, null, _react["default"].createElement("div", {
        ref: this.scrollPanelRef,
        onScroll: this.onScroll,
        onKeyDown: this.onKeyDown,
        style: _objectSpread({
          position: "relative",
          overflow: "auto",
          WebkitOverflowScrolling: "touch",
          width: "100%",
          height: "100%",
          padding: "0px",
          marginBottom: "0px",
          marginRight: "0px"
        }, autoSize ? scrollPanelSize.getCSS() : {}),
        tabIndex: "0"
      }, _react["default"].createElement("div", {
        ref: this.mousePanelRef,
        onMouseMove: this.onMouseMove,
        onClick: this.onClick,
        onChange: this.onCheckboxChange,
        style: _objectSpread({
          position: "absolute",
          overflow: "hidden"
        }, mousePanelSize.getCSS())
      }, _react["default"].createElement("div", {
        ref: this.placeholderRef,
        style: _objectSpread({}, placeholderRectCSS, {
          position: "absolute",
          overflow: "hidden",
          "transformOrigin": "0 0",
          "transform": scaletext,
          "msTransform": scaletext,

          /* IE 9 */
          "WebkitTransform": scaletext,

          /* Safari and Chrome */
          "OTransform": scaletext,

          /* Opera */
          "MozTransform": scaletext
          /* Firefox */

        })
      }, graphics.map(this, "placeholder", function (layerKey, elements) {
        return _react["default"].createElement("div", {
          key: layerKey,
          style: {
            position: "absolute",
            overflow: "visible",
            left: "0px",
            top: "0px"
          }
        }, elements);
      }), calloutplaceholder && _react["default"].createElement("div", {
        key: "Callout",
        style: {
          position: "absolute",
          overflow: "visible",
          left: calloutplaceholder.rect.x + "px",
          top: calloutplaceholder.rect.y + "px"
        }
      }, graphics.map(this, "calloutplaceholder", function (layerKey, elements) {
        return _react["default"].createElement("div", {
          key: layerKey,
          style: {
            position: "absolute",
            overflow: "visible"
          }
        }, elements);
      }))))));
    }
  }]);

  return BaseDiagram;
}(_react.Component);

_defineProperty(BaseDiagram, "propTypes", {
  centerOnCursor: _propTypes["default"].bool,
  // eslint-disable-line react/no-unused-prop-types
  onHighlightChanging: _propTypes["default"].func,
  // eslint-disable-line react/no-unused-prop-types
  onHighlightChanged: _propTypes["default"].func,
  // eslint-disable-line react/no-unused-prop-types
  onCursorChanging: _propTypes["default"].func,
  // eslint-disable-line react/no-unused-prop-types
  onCursorChanged: _propTypes["default"].func,
  // eslint-disable-line react/no-unused-prop-types
  onSelectionChanging: _propTypes["default"].func,
  // eslint-disable-line react/no-unused-prop-types
  onSelectionChanged: _propTypes["default"].func // eslint-disable-line react/no-unused-prop-types

});

_defineProperty(BaseDiagram, "defaultProps", {
  centerOnCursor: true,
  onHighlightChanging: null,
  onHighlightChanged: null,
  onCursorChanging: null,
  onCursorChanged: null,
  onSelectionChanging: null,
  onSelectionChanged: null
});

var _default = BaseDiagram;
exports["default"] = _default;